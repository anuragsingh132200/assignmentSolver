"""
Git Utility Tool
Manages Git operations for version control and repository management.
"""

import os
import subprocess
import logging
from typing import Dict, List, Any, Optional
from pathlib import Path

logger = logging.getLogger(__name__)


class GitManager:
    """Tool for managing Git operations and repository management."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def init_repository(self, repo_path: str, initial_commit: bool = True) -> Dict[str, Any]:
        """
        Initialize a new Git repository.
        
        Args:
            repo_path: Path where to initialize the repository
            initial_commit: Whether to create an initial commit
            
        Returns:
            Dict containing operation results
        """
        try:
            self.logger.info(f"Initializing Git repository at {repo_path}")
            
            # Create directory if it doesn't exist
            Path(repo_path).mkdir(parents=True, exist_ok=True)
            
            # Initialize Git repository
            result = subprocess.run(
                ["git", "init"],
                cwd=repo_path,
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                return {
                    "status": "error",
                    "error": f"Failed to initialize repository: {result.stderr}"
                }
            
            # Configure Git user (use default values for demo)
            subprocess.run(
                ["git", "config", "user.name", "Assignment Assistant Agent"],
                cwd=repo_path,
                capture_output=True
            )
            
            subprocess.run(
                ["git", "config", "user.email", "agent@assignment-assistant.com"],
                cwd=repo_path,
                capture_output=True
            )
            
            # Create .gitignore file
            self._create_gitignore(repo_path)
            
            # Add all files and create initial commit if requested
            if initial_commit:
                add_result = subprocess.run(
                    ["git", "add", "."],
                    cwd=repo_path,
                    capture_output=True,
                    text=True
                )
                
                if add_result.returncode == 0:
                    commit_result = subprocess.run(
                        ["git", "commit", "-m", "Initial commit - Generated by Assignment Assistant Agent"],
                        cwd=repo_path,
                        capture_output=True,
                        text=True
                    )
                    
                    if commit_result.returncode != 0:
                        return {
                            "status": "warning",
                            "message": "Repository initialized but initial commit failed",
                            "error": commit_result.stderr
                        }
            
            return {
                "status": "success",
                "message": "Repository initialized successfully",
                "repo_path": repo_path,
                "initial_commit": initial_commit
            }
            
        except Exception as e:
            self.logger.error(f"Error initializing repository: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def add_files(self, repo_path: str, files: List[str] = None) -> Dict[str, Any]:
        """
        Add files to Git staging area.
        
        Args:
            repo_path: Path to the Git repository
            files: List of files to add (None means add all)
            
        Returns:
            Dict containing operation results
        """
        try:
            if files is None:
                # Add all files
                result = subprocess.run(
                    ["git", "add", "."],
                    cwd=repo_path,
                    capture_output=True,
                    text=True
                )
            else:
                # Add specific files
                cmd = ["git", "add"] + files
                result = subprocess.run(
                    cmd,
                    cwd=repo_path,
                    capture_output=True,
                    text=True
                )
            
            if result.returncode != 0:
                return {
                    "status": "error",
                    "error": f"Failed to add files: {result.stderr}"
                }
            
            return {
                "status": "success",
                "message": f"Files added successfully",
                "files_added": files or "all"
            }
            
        except Exception as e:
            self.logger.error(f"Error adding files: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def commit_changes(self, repo_path: str, message: str) -> Dict[str, Any]:
        """
        Commit staged changes.
        
        Args:
            repo_path: Path to the Git repository
            message: Commit message
            
        Returns:
            Dict containing operation results
        """
        try:
            result = subprocess.run(
                ["git", "commit", "-m", message],
                cwd=repo_path,
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                return {
                    "status": "error",
                    "error": f"Failed to commit: {result.stderr}"
                }
            
            return {
                "status": "success",
                "message": "Changes committed successfully",
                "commit_message": message
            }
            
        except Exception as e:
            self.logger.error(f"Error committing changes: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def create_branch(self, repo_path: str, branch_name: str, checkout: bool = True) -> Dict[str, Any]:
        """
        Create a new branch.
        
        Args:
            repo_path: Path to the Git repository
            branch_name: Name of the new branch
            checkout: Whether to checkout the new branch
            
        Returns:
            Dict containing operation results
        """
        try:
            if checkout:
                # Create and checkout branch
                result = subprocess.run(
                    ["git", "checkout", "-b", branch_name],
                    cwd=repo_path,
                    capture_output=True,
                    text=True
                )
            else:
                # Just create branch
                result = subprocess.run(
                    ["git", "branch", branch_name],
                    cwd=repo_path,
                    capture_output=True,
                    text=True
                )
            
            if result.returncode != 0:
                return {
                    "status": "error",
                    "error": f"Failed to create branch: {result.stderr}"
                }
            
            return {
                "status": "success",
                "message": f"Branch '{branch_name}' created successfully",
                "branch_name": branch_name,
                "checked_out": checkout
            }
            
        except Exception as e:
            self.logger.error(f"Error creating branch: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def get_status(self, repo_path: str) -> Dict[str, Any]:
        """
        Get Git repository status.
        
        Args:
            repo_path: Path to the Git repository
            
        Returns:
            Dict containing repository status
        """
        try:
            # Get status
            status_result = subprocess.run(
                ["git", "status", "--porcelain"],
                cwd=repo_path,
                capture_output=True,
                text=True
            )
            
            # Get current branch
            branch_result = subprocess.run(
                ["git", "branch", "--show-current"],
                cwd=repo_path,
                capture_output=True,
                text=True
            )
            
            # Get last commit
            log_result = subprocess.run(
                ["git", "log", "-1", "--oneline"],
                cwd=repo_path,
                capture_output=True,
                text=True
            )
            
            # Parse status
            status_lines = status_result.stdout.strip().split('\n') if status_result.stdout.strip() else []
            modified_files = []
            untracked_files = []
            
            for line in status_lines:
                if line.startswith('??'):
                    untracked_files.append(line[3:])
                else:
                    modified_files.append(line)
            
            return {
                "status": "success",
                "current_branch": branch_result.stdout.strip() if branch_result.returncode == 0 else "unknown",
                "last_commit": log_result.stdout.strip() if log_result.returncode == 0 else "no commits",
                "modified_files": modified_files,
                "untracked_files": untracked_files,
                "is_clean": len(modified_files) == 0 and len(untracked_files) == 0
            }
            
        except Exception as e:
            self.logger.error(f"Error getting status: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def push_to_remote(self, repo_path: str, remote_name: str = "origin", branch: str = None) -> Dict[str, Any]:
        """
        Push changes to remote repository.
        
        Args:
            repo_path: Path to the Git repository
            remote_name: Name of the remote repository
            branch: Branch to push (None means current branch)
            
        Returns:
            Dict containing operation results
        """
        try:
            if branch is None:
                # Get current branch
                branch_result = subprocess.run(
                    ["git", "branch", "--show-current"],
                    cwd=repo_path,
                    capture_output=True,
                    text=True
                )
                branch = branch_result.stdout.strip()
            
            # Push to remote
            result = subprocess.run(
                ["git", "push", remote_name, branch],
                cwd=repo_path,
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                return {
                    "status": "error",
                    "error": f"Failed to push: {result.stderr}"
                }
            
            return {
                "status": "success",
                "message": f"Successfully pushed to {remote_name}/{branch}",
                "remote": remote_name,
                "branch": branch
            }
            
        except Exception as e:
            self.logger.error(f"Error pushing to remote: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def add_remote(self, repo_path: str, remote_name: str, remote_url: str) -> Dict[str, Any]:
        """
        Add a remote repository.
        
        Args:
            repo_path: Path to the Git repository
            remote_name: Name of the remote
            remote_url: URL of the remote repository
            
        Returns:
            Dict containing operation results
        """
        try:
            result = subprocess.run(
                ["git", "remote", "add", remote_name, remote_url],
                cwd=repo_path,
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                return {
                    "status": "error",
                    "error": f"Failed to add remote: {result.stderr}"
                }
            
            return {
                "status": "success",
                "message": f"Remote '{remote_name}' added successfully",
                "remote_name": remote_name,
                "remote_url": remote_url
            }
            
        except Exception as e:
            self.logger.error(f"Error adding remote: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def create_tag(self, repo_path: str, tag_name: str, message: str = None) -> Dict[str, Any]:
        """
        Create a Git tag.
        
        Args:
            repo_path: Path to the Git repository
            tag_name: Name of the tag
            message: Optional tag message
            
        Returns:
            Dict containing operation results
        """
        try:
            if message:
                result = subprocess.run(
                    ["git", "tag", "-a", tag_name, "-m", message],
                    cwd=repo_path,
                    capture_output=True,
                    text=True
                )
            else:
                result = subprocess.run(
                    ["git", "tag", tag_name],
                    cwd=repo_path,
                    capture_output=True,
                    text=True
                )
            
            if result.returncode != 0:
                return {
                    "status": "error",
                    "error": f"Failed to create tag: {result.stderr}"
                }
            
            return {
                "status": "success",
                "message": f"Tag '{tag_name}' created successfully",
                "tag_name": tag_name,
                "tag_message": message
            }
            
        except Exception as e:
            self.logger.error(f"Error creating tag: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def _create_gitignore(self, repo_path: str):
        """Create a .gitignore file with common patterns."""
        gitignore_path = os.path.join(repo_path, ".gitignore")
        
        gitignore_content = '''# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# pyenv
.python-version

# celery beat schedule file
celerybeat-schedule

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Assignment Agent specific
uploads/
data/vecstore/
logs/
*.log
'''
        
        with open(gitignore_path, "w") as f:
            f.write(gitignore_content)
    
    def get_commit_history(self, repo_path: str, limit: int = 10) -> Dict[str, Any]:
        """
        Get commit history.
        
        Args:
            repo_path: Path to the Git repository
            limit: Maximum number of commits to return
            
        Returns:
            Dict containing commit history
        """
        try:
            result = subprocess.run(
                ["git", "log", f"--max-count={limit}", "--oneline", "--pretty=format:%h %s %an %ad"],
                cwd=repo_path,
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                return {
                    "status": "error",
                    "error": f"Failed to get commit history: {result.stderr}"
                }
            
            commits = []
            for line in result.stdout.strip().split('\n'):
                if line:
                    parts = line.split(' ', 3)
                    if len(parts) >= 4:
                        commits.append({
                            "hash": parts[0],
                            "message": parts[1],
                            "author": parts[2],
                            "date": parts[3]
                        })
            
            return {
                "status": "success",
                "commits": commits,
                "total_commits": len(commits)
            }
            
        except Exception as e:
            self.logger.error(f"Error getting commit history: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
